// Select dots and sections
const dots = document.querySelectorAll('.dot');
const sections = document.querySelectorAll('.section');
const container = document.querySelector('.container');

// Track if chat animation has been triggered
let chatAnimationTriggered = false;

// Intersection Observer for detecting which section is visible
const observer = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const id = entry.target.getAttribute('id');
        // Remove active from all dots first
        dots.forEach((dot) => dot.classList.remove('active'));
        // Add active to the matching dot
        const activeDot = document.querySelector(`.dot[href="#${id}"]`);
        if (activeDot) {
          activeDot.classList.add('active');
        }

        // Trigger chat animation when section3 comes into view
        if (id === 'section3' && !chatAnimationTriggered) {
          chatAnimationTriggered = true;
          const messages = document.querySelectorAll('.message-container');
          messages.forEach((msg) => {
            msg.classList.add('animate');
          });
        }
      }
    });
  },
  { 
    root: container,
    threshold: 0.6  // Simplified - removed rootMargin
  }
);

// Observe each section
sections.forEach((section) => {
  observer.observe(section);
});

// Smooth scroll when clicking dots
dots.forEach((dot) => {
  dot.addEventListener('click', (e) => {
    e.preventDefault();
    const targetId = dot.getAttribute('href');
    const targetSection = document.querySelector(targetId);
    targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
});

// Game Data - Bot vs Human Detection Game (Using actual database content)
const gameData = [
  {
    id: 1,
    title: "",
    content: "In countries where coronaviruses cause disease, there is increasing support for putting an end to the use of experimental antiviral drugs. Some specialist groups fear that this will mean a shift in guidelines that could be catastrophic for those on the frontline. As a result, they are asking the public to step up and show their concerns in a public petition.",
    isBot: true,
    username: "@HealthNewsDaily",
    avatar: "ðŸ©º",
    handle: "healthnewsdaily"
  },
  {
    id: 2,
    title: "",
    content: "Barcelona's Champions League last-16 second leg match with Napoli, scheduled for 18 March, will take place without spectators due to fears over the spread of the coronavirus, a club spokesman said on Tuesday. The match will take place at Camp Nou after a 1-1 draw in Naples.",
    isBot: false,
    username: "@SportsReporter",
    avatar: "âš½",
    handle: "sportsreporter"
  },
  {
    id: 3,
    title: "",
    content: "Noonan also went on to argue that AI is more than a buzzword, explaining that 'programs are not neutral; they have effects.' Because of the importance of ethics in AI research, she argued that 'no one ever sat down and wrote a paper' on the topic. It is important to note that Noonan is fully aware that she is the embodiment of what she is not: a hacker.",
    isBot: true,
    username: "@TechEthics",
    avatar: "ðŸ¤–",
    handle: "techethics"
  },
  {
    id: 4,
    title: "",
    content: "Click over to Google, type in 'coronavirus', and press enter. The results you see will bear little resemblance to any other search. There are no ads, no product recommendations, and no links to websites that have figured out how to win the search engine optimisation game. Government, NGO and mainstream media sources dominate.",
    isBot: false,
    username: "@TechReporter",
    avatar: "ðŸ’»",
    handle: "techreporter"
  },
  {
    id: 5,
    title: "",
    content: "Although no opening date has been set, Cruise is expected to return to the helm of 'Mission: Impossible' within a year of the release of 'Tomorrowland,' according to NASA. Launching from Kennedy Space Center's pad 39A, Cruise is set to return to the global screen in July, when 'Mission: Impossible III' is scheduled to arrive in theaters.",
    isBot: true,
    username: "@MovieNews",
    avatar: "ðŸŽ¬",
    handle: "movienews"
  },
  {
    id: 6,
    title: "",
    content: "SAN FRANCISCO â€” Several months ago, Google hired dozens of actors to sit at a table, stand in a hallway and walk down a street while talking into a video camera. Then the company's researchers, using a new kind of artificial intelligence software, swapped the faces of the actors. People who had been walking were suddenly at a table.",
    isBot: false,
    username: "@DigitalNews",
    avatar: "ðŸŒ",
    handle: "digitalnews"
  }
];

// Game State
let currentQuestion = 0;
let score = 0;
let gameStarted = false;

// Game Elements
const tweetCard = document.getElementById('tweetCard');
const tweetTitle = document.getElementById('tweetTitle');
const tweetText = document.getElementById('tweetText');
const tweetUsername = document.getElementById('tweetUsername');
const tweetAvatar = document.getElementById('tweetAvatar');
const tweetTime = document.getElementById('tweetTime');
const humanBtn = document.getElementById('humanBtn');
const botBtn = document.getElementById('botBtn');
const feedback = document.getElementById('feedback');
const scoreEl = document.getElementById('score');
const totalEl = document.getElementById('total');
const currentEl = document.getElementById('current');
const totalQuestionsEl = document.getElementById('totalQuestions');
const finalResults = document.getElementById('finalResults');
const finalScore = document.getElementById('finalScore');
const finalTotal = document.getElementById('finalTotal');
const finalMessage = document.getElementById('finalMessage');
const restartBtn = document.getElementById('restartBtn');
const commentsEl = document.getElementById('comments');
const retweetsEl = document.getElementById('retweets');
const likesEl = document.getElementById('likes');

// Initialize game
function initGame() {
  currentQuestion = 0;
  score = 0;
  gameStarted = true;
  finalResults.style.display = 'none';
  updateScore();
  loadQuestion();
}

// Update score display
function updateScore() {
  scoreEl.textContent = score;
  totalEl.textContent = gameData.length;
  currentEl.textContent = currentQuestion + 1;
  totalQuestionsEl.textContent = gameData.length;
}

// Generate random social media stats
function generateStats() {
  const comments = Math.floor(Math.random() * 100) + 5;
  const retweets = Math.floor(Math.random() * 200) + 10;
  const likes = Math.floor(Math.random() * 1000) + 50;
  
  commentsEl.textContent = comments;
  retweetsEl.textContent = retweets;
  likesEl.textContent = likes;
}

// Load current question
function loadQuestion() {
  if (currentQuestion >= gameData.length) {
    endGame();
    return;
  }

  const question = gameData[currentQuestion];
  
  tweetTitle.textContent = question.title;
  tweetText.textContent = question.content;
  tweetUsername.textContent = question.username;
  tweetAvatar.textContent = question.avatar;
  
  // Random time
  const times = ['2m', '5m', '12m', '1h', '2h', '4h'];
  tweetTime.textContent = times[Math.floor(Math.random() * times.length)];
  
  generateStats();
  
  // Reset buttons
  humanBtn.disabled = false;
  botBtn.disabled = false;
  humanBtn.style.opacity = '1';
  botBtn.style.opacity = '1';
  
  feedback.textContent = '';
  feedback.className = 'feedback';
  
  updateScore();
}

// Handle answer
function handleAnswer(isBot) {
  const correct = gameData[currentQuestion].isBot === isBot;
  
  if (correct) {
    score++;
    feedback.textContent = 'âœ… Correct!';
    feedback.className = 'feedback correct';
  } else {
    const actualType = gameData[currentQuestion].isBot ? 'AI Generated' : 'Human Written';
    feedback.textContent = `âŒ Wrong! This was ${actualType}`;
    feedback.className = 'feedback incorrect';
  }
  
  // Disable buttons
  humanBtn.disabled = true;
  botBtn.disabled = true;
  humanBtn.style.opacity = '0.5';
  botBtn.style.opacity = '0.5';
  
  updateScore();
  
  // Move to next question after delay
  setTimeout(() => {
    currentQuestion++;
    loadQuestion();
  }, 2000);
}

// End game
function endGame() {
  finalScore.textContent = score;
  finalTotal.textContent = gameData.length;
  
  const percentage = (score / gameData.length) * 100;
  let message = '';
  
  if (percentage >= 80) {
    message = 'ðŸŽ‰ Excellent! You have great digital literacy skills!';
  } else if (percentage >= 60) {
    message = 'ðŸ‘ Good job! You can spot most fake content.';
  } else if (percentage >= 40) {
    message = 'ðŸ¤” Not bad, but there\'s room for improvement in detecting AI content.';
  } else {
    message = 'ðŸ“š Keep practicing! AI detection is tricky but learnable.';
  }
  
  finalMessage.textContent = message;
  finalResults.style.display = 'block';
  tweetCard.style.display = 'none';
  document.querySelector('.game-buttons').style.display = 'none';
  document.querySelector('.game-question').style.display = 'none';
}

// Event listeners
if (humanBtn && botBtn) {
  humanBtn.addEventListener('click', () => handleAnswer(false));
  botBtn.addEventListener('click', () => handleAnswer(true));
}

if (restartBtn) {
  restartBtn.addEventListener('click', () => {
    tweetCard.style.display = 'block';
    document.querySelector('.game-buttons').style.display = 'flex';
    document.querySelector('.game-question').style.display = 'block';
    initGame();
  });
}

// Start game when section 6 comes into view
const gameObserver = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting && entry.target.id === 'section6' && !gameStarted) {
        initGame();
      }
    });
  },
  { 
    root: container,
    threshold: 0.5
  }
);

const section6 = document.getElementById('section6');
if (section6) {
  gameObserver.observe(section6);
}

// Wait for DOM content to be loaded before creating the pie chart
document.addEventListener('DOMContentLoaded', () => {
  try {
    console.log('Creating pie chart...');

    // Dimensions and radius
    const width = 600, height = 600, radius = Math.min(width, height) / 2;

    // Color scheme
    const color = d3.scaleOrdinal()
      .domain(["Human", "Bot"])
      .range(["#286cd8ff", "#ec1010ff"]);

    // Create the SVG container
    const chartDiv = document.getElementById('chart');
    if (!chartDiv) {
      console.error('#chart element not found');
      return;
    }

    const svg = d3.select("#chart")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", `translate(${width / 2}, ${height / 2})`);

    const arc = d3.arc()
      .innerRadius(0)
      .outerRadius(radius - 20);

    const pie = d3.pie()
      .sort(null)
      .value(d => d.count);

    // Sample data
    const data = [
      { type: "Human", count: 96.76 },
      { type: "Bot", count: 3.24 }
    ];

    console.log('Data for pie chart:', data);

    // Create pie slices
    const arcs = pie(data);

    // Add paths
    svg.selectAll("path")
      .data(arcs)
      .enter()
      .append("path")
      .attr("fill", d => color(d.data.type))
      .attr("d", arc)
      .attr("stroke", "white")
      .attr("stroke-width", 1);

    // Add labels
    svg.selectAll("text")
      .data(arcs)
      .enter()
      .append("text")
      .attr("class", "label")
      .attr("transform", d => `translate(${arc.centroid(d)})`)
      .attr("dy", "0.35em")
      .attr("text-anchor", "middle")
      .text(d => `${d.data.type} (${((d.data.count / d3.sum(data, d=>d.count))*100).toFixed(1)}%)`);

    console.log('Pie chart created successfully');
  } catch (error) {
    console.error('Error creating pie chart:', error);
    const chartEl = document.getElementById('chart');
    if (chartEl) {
      chartEl.innerHTML = '<p style="color:#fff; text-align:center; padding:2rem;">Error creating pie chart. Check console for details.</p>';
    }
  }
});

// ========== BOT ENGAGEMENT CHARTS ==========
document.addEventListener('DOMContentLoaded', async () => {
  const chartDiv = d3.select("#chart-ignored");
  const tooltip = d3.select(".tooltip");

  if (chartDiv.empty()) {
    console.warn('No #chart-ignored element found; skipping chart');
    return;
  }

  const width = 900, height = 450;

  // Show loading message
  const loadingText = chartDiv.append('div')
    .style('color', 'white')
    .style('text-align', 'center')
    .style('padding', '2rem')
    .style('font-size', '18px')
    .text('Loading data...');

  try {
    // Load CSV data
    const data = await d3.csv('Datasets/Features_For_Traditional_ML_Techniques.csv');
    console.log('CSV loaded. Rows:', data.length);

    // Analyze bot vs human engagement
    let botZeroRetweets = 0;
    let humanZeroRetweets = 0;
    let botTotal = 0;
    let humanTotal = 0;
    let botTotalRetweets = 0;
    let humanTotalRetweets = 0;

    data.forEach(row => {
      const botBinary = row.BotScoreBinary ? row.BotScoreBinary.trim() : '';
      const retweetsStr = row.retweets ? row.retweets.trim() : '';

      if (botBinary && retweetsStr) {
        try {
          const isBot = parseFloat(botBinary) === 1.0;
          const retweets = parseFloat(retweetsStr);

          if (isBot) {
            botTotal++;
            botTotalRetweets += retweets;
            if (retweets === 0.0) botZeroRetweets++;
          } else {
            humanTotal++;
            humanTotalRetweets += retweets;
            if (retweets === 0.0) humanZeroRetweets++;
          }
        } catch (e) {
          // Skip invalid rows
        }
      }
    });

    const botZeroPct = botTotal > 0 ? (botZeroRetweets / botTotal * 100) : 0;
    const humanZeroPct = humanTotal > 0 ? (humanZeroRetweets / humanTotal * 100) : 0;
    const totalRetweets = botTotalRetweets + humanTotalRetweets;
    const botEngagementPct = totalRetweets > 0 ? (botTotalRetweets / totalRetweets * 100) : 0;

    console.log('Bot accounts:', botTotal);
    console.log('Human accounts:', humanTotal);
    console.log('Bots with zero retweets:', botZeroPct.toFixed(1) + '%');
    console.log('Humans with zero retweets:', humanZeroPct.toFixed(1) + '%');
    console.log('Bot retweet engagement:', botEngagementPct.toFixed(4) + '%');

    loadingText.remove();

    const dataset = [
      { type: 'Bots', percentage: botZeroPct },
      { type: 'Humans', percentage: humanZeroPct }
    ];

    const donutData = [
      { type: 'Bots', value: botEngagementPct },
      { type: 'Humans', value: 100 - botEngagementPct }
    ];

    console.log('Chart data loaded');
    console.log('Bar chart:', dataset);
    console.log('Donut chart:', donutData);

    try {
      // Create container for both charts side by side
      const containerDiv = chartDiv.append("div")
        .style("display", "flex")
        .style("flex-direction", "row")
        .style("justify-content", "center")
        .style("align-items", "center")
        .style("gap", "40px")
        .style("flex-wrap", "nowrap")
        .style("padding", "20px")
        .style("max-width", "100%")
        .style("margin", "0 auto");

      // ========== BAR CHART: Tweets with Zero Retweets ==========
      const barWidth = 450, barHeight = 420;
      const barMargin = { top: 70, right: 25, bottom: 70, left: 90 };

      const barSvg = containerDiv.append("svg")
        .attr("width", barWidth)
        .attr("height", barHeight)
        .style("background", "rgba(255, 255, 255, 0.03)")
        .style("border-radius", "16px")
        .style("box-shadow", "0 8px 20px rgba(0, 0, 0, 0.5)")
        .style("border", "1px solid rgba(255, 255, 255, 0.1)");

      const barG = barSvg.append("g")
        .attr("transform", `translate(${barMargin.left},${barMargin.top})`);

      const barInnerWidth = barWidth - barMargin.left - barMargin.right;
      const barInnerHeight = barHeight - barMargin.top - barMargin.bottom;

      const x = d3.scaleBand()
        .domain(dataset.map(d => d.type))
        .range([0, barInnerWidth])
        .padding(0.4);

      const y = d3.scaleLinear()
        .domain([0, 100])
        .range([barInnerHeight, 0]);

      // Grid lines
      barG.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(y)
          .tickSize(-barInnerWidth)
          .tickFormat("")
        )
        .selectAll("line")
        .style("stroke", "rgba(255,255,255,0.1)")
        .style("stroke-dasharray", "3,3");

      barG.selectAll(".grid .domain")
        .style("stroke", "none");

      // Axes
      barG.append("g")
        .attr("transform", `translate(0,${barInnerHeight})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
        .style("font-size", "17px")
        .style("font-weight", "700")
        .style("fill", "white");

      barG.append("g")
        .call(d3.axisLeft(y).tickFormat(d => d + "%").ticks(5))
        .selectAll("text")
        .style("font-size", "14px")
        .style("font-weight", "500")
        .style("fill", "#e0e0e0");

      // Style axis lines and ticks
      barG.selectAll(".domain")
        .style("stroke", "rgba(255,255,255,0.4)")
        .style("stroke-width", "2px");
      
      barG.selectAll(".tick line")
        .style("stroke", "rgba(255,255,255,0.25)");

      // Bars with animation
      barG.selectAll(".bar")
        .data(dataset)
        .enter()
        .append("rect")
        .attr("class", "bar")
        .attr("x", d => x(d.type))
        .attr("width", x.bandwidth())
        .attr("y", barInnerHeight)
        .attr("height", 0)
        .attr("fill", d => d.type === "Bots" ? "#ec1010ff" : "#286cd8ff")
        .attr("rx", 6)
        .attr("ry", 6)
        .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.4))")
        .transition()
        .duration(1500)
        .ease(d3.easeCubicOut)
        .attr("y", d => y(d.percentage))
        .attr("height", d => barInnerHeight - y(d.percentage));

      // Labels on bars
      barG.selectAll(".bar-label")
        .data(dataset)
        .enter()
        .append("text")
        .attr("class", "bar-label")
        .attr("x", d => x(d.type) + x.bandwidth() / 2)
        .attr("y", d => y(d.percentage) - 15)
        .attr("text-anchor", "middle")
        .attr("fill", "white")
        .attr("font-size", "26px")
        .attr("font-weight", "bold")
        .style("text-shadow", "0 3px 6px rgba(0,0,0,0.7)")
        .text(d => d.percentage.toFixed(1) + "%");

      // Chart subtitle
      barG.append("text")
        .attr("x", barInnerWidth / 2)
        .attr("y", -40)
        .attr("text-anchor", "middle")
        .attr("fill", "white")
        .attr("font-size", "16px")
        .attr("font-weight", "700")
        .style("letter-spacing", "0.5px")
        .text("Most bot tweets get no retweets");

      // Y-axis label
      barG.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -barInnerHeight / 2)
        .attr("y", -70)
        .attr("text-anchor", "middle")
        .attr("fill", "#b0b0b0")
        .attr("font-size", "13px")
        .attr("font-weight", "500")
        .text("Percent of tweets with zero retweets");

      // ========== DONUT CHART: Retweet Engagement Composition ==========
      const donutWidth = 450, donutHeight = 420;
      const donutRadius = Math.min(donutWidth, donutHeight) / 2 - 60;

      const donutSvg = containerDiv.append("svg")
        .attr("width", donutWidth)
        .attr("height", donutHeight)
        .style("background", "rgba(255, 255, 255, 0.03)")
        .style("border-radius", "16px")
        .style("box-shadow", "0 8px 20px rgba(0, 0, 0, 0.5)")
        .style("border", "1px solid rgba(255, 255, 255, 0.1)");

      const donutG = donutSvg.append("g")
        .attr("transform", `translate(${donutWidth / 2},${donutHeight / 2 + 15})`);

      const color = d3.scaleOrdinal()
        .domain(["Bots", "Humans"])
        .range(["#ec1010ff", "#286cd8ff"]);

      const pie = d3.pie()
        .value(d => d.value)
        .sort(null);

      const arc = d3.arc()
        .innerRadius(donutRadius * 0.6)
        .outerRadius(donutRadius);

      // Draw donut slices
      const paths = donutG.selectAll("path")
        .data(pie(donutData))
        .enter()
        .append("path")
        .attr("d", arc)
        .attr("fill", d => color(d.data.type))
        .attr("stroke", "white")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.4))")
        .style("opacity", 0);

      paths.transition()
        .duration(1500)
        .ease(d3.easeCubicOut)
        .style("opacity", 1)
        .attrTween("d", function(d) {
          const i = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
          return function(t) { return arc(i(t)); };
        });

      // Center text
      donutG.append("text")
        .attr("text-anchor", "middle")
        .attr("y", -18)
        .attr("fill", "#ec1010ff")
        .attr("font-size", "24px")
        .attr("font-weight", "bold")
        .style("text-shadow", "0 3px 6px rgba(0,0,0,0.7)")
        .text(`Bots = ${donutData[0].value.toFixed(4)}%`);

      donutG.append("text")
        .attr("text-anchor", "middle")
        .attr("y", 8)
        .attr("fill", "white")
        .attr("font-size", "15px")
        .attr("font-weight", "500")
        .text("of all retweet engagement");

      // Chart title
      donutG.append("text")
        .attr("text-anchor", "middle")
        .attr("y", -donutRadius - 45)
        .attr("fill", "white")
        .attr("font-size", "16px")
        .attr("font-weight", "700")
        .style("letter-spacing", "0.5px")
        .text("Bots are 0.0555% of all retweet engagement");

      donutG.append("text")
        .attr("text-anchor", "middle")
        .attr("y", -donutRadius - 23)
        .attr("fill", "#b0b0b0")
        .attr("font-size", "13px")
        .attr("font-weight", "500")
        .text("Composition of total retweets");

      // Legend
      const legend = donutSvg.append("g")
        .attr("transform", `translate(${donutWidth - 115}, ${donutHeight - 75})`);

      const legendData = [
        { label: "Bots", color: "#ec1010ff" },
        { label: "Humans", color: "#286cd8ff" }
      ];

      legendData.forEach((d, i) => {
        const legendRow = legend.append("g")
          .attr("transform", `translate(0, ${i * 28})`);

        legendRow.append("rect")
          .attr("width", 18)
          .attr("height", 18)
          .attr("rx", 4)
          .attr("fill", d.color)
          .style("filter", "drop-shadow(0px 2px 3px rgba(0,0,0,0.4))");

        legendRow.append("text")
          .attr("x", 26)
          .attr("y", 13)
          .attr("fill", "white")
          .attr("font-size", "15px")
          .attr("font-weight", "600")
          .text(d.label);
      });

      console.log('Charts rendered successfully!');
      
    } catch (renderError) {
      console.error('Error rendering charts:', renderError);
      chartDiv.html('').append('div')
        .style('color', '#ff6b6b')
        .style('text-align', 'center')
        .style('padding', '2rem')
        .text('Error rendering charts. Check console for details.');
    }
  } catch (loadError) {
    console.error('Error loading data:', loadError);
    loadingText
      .style('color', '#ff6b6b')
      .text('Error loading data. Check console for details.');
  }
});

// ========================================
// PREDICTION SECTION INTERACTION
// ========================================
document.addEventListener('DOMContentLoaded', () => {
  const predictionBtns = document.querySelectorAll('.prediction-btn');
  const resultDiv = document.getElementById('predictionResult');
  
  predictionBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      // Disable all buttons after one is clicked
      predictionBtns.forEach(b => b.disabled = true);
      
      const isCorrect = btn.dataset.answer === 'correct';
      
      // Add visual feedback
      if (isCorrect) {
        btn.classList.add('selected-correct');
      } else {
        btn.classList.add('selected-wrong');
        // Also highlight the correct answer
        const correctBtn = document.querySelector('.prediction-btn[data-answer="correct"]');
        setTimeout(() => {
          correctBtn.classList.add('selected-correct');
        }, 500);
      }
      
      // Show the result after a delay
      setTimeout(() => {
        resultDiv.style.display = 'block';
      }, 1000);
    });
  });
});

// ========================================
// GOOGLE SEARCH TREND CHART
// ========================================
document.addEventListener('DOMContentLoaded', () => {
  const chartContainer = document.getElementById('searchTrendChart');
  
  if (!chartContainer) return;
  
  let currentData = [];
  let svg, xScale, yScale, line, area, path, dots, peakCircle, peakLabel;
  
  // Load the CSV data using d3.text to handle custom format
  d3.text('search_traffic_google.csv').then(text => {
    // Split into lines and skip the first line (category header)
    const lines = text.split('\n').slice(2); // Skip first 2 lines
    
    // Parse the data
    const allData = lines
      .map(line => {
        const [dateStr, valueStr] = line.split(',');
        if (!dateStr || !valueStr) return null;
        
        const date = d3.timeParse('%Y-%m-%d')(dateStr.trim());
        const value = +valueStr.trim();
        
        return { date, value };
      })
      .filter(d => d && d.date && !isNaN(d.value));
    
    if (allData.length === 0) {
      chartContainer.innerHTML = '<p style="color: #ff6b6b; text-align: center;">No valid data found</p>';
      return;
    }
    
    currentData = allData;
    
    // Update stats
    updateStats(allData);
    
    // Initial render
    renderChart(allData);
    
    // Setup interactive controls
    setupControls(allData);
    
  }).catch(error => {
    console.error('Error loading search trend data:', error);
    chartContainer.innerHTML = '<p style="color: #ff6b6b; text-align: center;">Error loading chart data</p>';
  });
  
  function updateStats(data) {
    // Calculate sustained attention metrics (2023-2025)
    const sustainedStartDate = new Date('2023-01-01');
    const sustainedData = data.filter(d => d.date >= sustainedStartDate && d.value > 0);
    
    // Average interest in recent period
    const avgRecent = sustainedData.length > 0 
      ? (sustainedData.reduce((sum, d) => sum + d.value, 0) / sustainedData.length).toFixed(1)
      : 0;
    
    // Number of months with consistent attention
    const consistentMonths = sustainedData.length;
    
    // Growth since 2020
    const firstNonZero = data.find(d => d.value > 0);
    const growth = firstNonZero ? (((avgRecent - firstNonZero.value) / Math.max(firstNonZero.value, 1)) * 100).toFixed(0) : 'âˆž';
    
    document.getElementById('avgRecent').textContent = avgRecent;
    document.getElementById('consistentMonths').textContent = consistentMonths;
    document.getElementById('growthRate').textContent = growth === 'Infinity' ? 'âˆž' : `+${growth}%`;
  }
  
  function setupControls(allData) {
    const buttons = document.querySelectorAll('.chart-btn');
    
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        buttons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Filter data based on view
        const view = btn.dataset.view;
        let filteredData = allData;
        
        if (view === 'recent') {
          const twoYearsAgo = new Date();
          twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
          filteredData = allData.filter(d => d.date >= twoYearsAgo);
        } else if (view === 'peak') {
          const peakData = allData.reduce((max, d) => d.value > max.value ? d : max, allData[0]);
          const peakDate = peakData.date;
          const sixMonthsBefore = new Date(peakDate);
          sixMonthsBefore.setMonth(sixMonthsBefore.getMonth() - 6);
          const sixMonthsAfter = new Date(peakDate);
          sixMonthsAfter.setMonth(sixMonthsAfter.getMonth() + 6);
          filteredData = allData.filter(d => d.date >= sixMonthsBefore && d.date <= sixMonthsAfter);
        }
        
        // Re-render with filtered data
        updateChart(filteredData);
      });
    });
  }
  
  function renderChart(data) {
    // Clear previous chart
    d3.select('#searchTrendChart').selectAll('*').remove();
    
    // Set up dimensions - MASSIVE, INTERACTIVE CHART
    const margin = { top: 80, right: 100, bottom: 120, left: 120 };
    const width = Math.min(1800, window.innerWidth * 0.95) - margin.left - margin.right;
    const height = 750 - margin.top - margin.bottom;
    
    // Create SVG
    svg = d3.select('#searchTrendChart')
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Create gradient for area
    const gradient = svg.append('defs')
      .append('linearGradient')
      .attr('id', 'areaGradient')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '0%')
      .attr('y2', '100%');
    
    gradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#1D9BF0')
      .attr('stop-opacity', 0.8);
    
    gradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#1D9BF0')
      .attr('stop-opacity', 0.1);
    
    // Set up scales
    xScale = d3.scaleTime()
      .domain(d3.extent(data, d => d.date))
      .range([0, width]);
    
    yScale = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.value) * 1.15])
      .range([height, 0]);
    
    // Add horizontal grid lines
    svg.append('g')
      .attr('class', 'chart-grid')
      .call(d3.axisLeft(yScale)
        .tickSize(-width)
        .tickFormat(''));
    
    // Add vertical grid lines for better clarity
    svg.append('g')
      .attr('class', 'chart-grid')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(xScale)
        .ticks(14)
        .tickSize(-height)
        .tickFormat(''));
    
    // Create line generator
    line = d3.line()
      .x(d => xScale(d.date))
      .y(d => yScale(d.value))
      .curve(d3.curveMonotoneX);
    
    // Create area generator
    area = d3.area()
      .x(d => xScale(d.date))
      .y0(height)
      .y1(d => yScale(d.value))
      .curve(d3.curveMonotoneX);
    
    // Add area with fade-in animation
    const areaPath = svg.append('path')
      .datum(data)
      .attr('class', 'line-chart-area')
      .attr('d', area)
      .style('opacity', 0);
    
    areaPath.transition()
      .delay(500)
      .duration(1500)
      .style('opacity', 1);
    
    // Add line with enhanced drawing animation
    path = svg.append('path')
      .datum(data)
      .attr('class', 'line-chart-path')
      .attr('d', line);
    
    // Animate line drawing with stroke-dasharray
    const pathLength = path.node().getTotalLength();
    path
      .attr('stroke-dasharray', pathLength + ' ' + pathLength)
      .attr('stroke-dashoffset', pathLength)
      .transition()
      .duration(3000)
      .ease(d3.easeLinear)
      .attr('stroke-dashoffset', 0);
    
    // Add axes with larger, more readable text
    const xAxis = d3.axisBottom(xScale)
      .ticks(14)
      .tickFormat(d3.timeFormat('%b \'%y'))
      .tickSize(10)
      .tickPadding(12);
    
    const yAxis = d3.axisLeft(yScale)
      .ticks(12)
      .tickSize(10)
      .tickPadding(12);
    
    svg.append('g')
      .attr('class', 'chart-axis')
      .attr('transform', `translate(0,${height})`)
      .call(xAxis)
      .selectAll('text')
      .style('text-anchor', 'end')
      .style('font-size', '18px')
      .style('font-weight', '600')
      .attr('dx', '-.8em')
      .attr('dy', '.15em')
      .attr('transform', 'rotate(-45)');
    
    svg.append('g')
      .attr('class', 'chart-axis')
      .call(yAxis)
      .selectAll('text')
      .style('font-size', '18px')
      .style('font-weight', '600');
    
    // Add axis labels with large, bold sans-serif text
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', height + 100)
      .style('text-anchor', 'middle')
      .style('fill', '#E7E9EA')
      .style('font-size', '24px')
      .style('font-weight', '700')
      .style('letter-spacing', '1.5px')
      .style('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif')
      .text('Time Period');
    
    svg.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', -85)
      .style('text-anchor', 'middle')
      .style('fill', '#E7E9EA')
      .style('font-size', '24px')
      .style('font-weight', '700')
      .style('letter-spacing', '1.5px')
      .style('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif')
      .text('Search Interest (Relative)');
    
    // Create tooltip
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'chart-tooltip');
    
    // Add interactive dots - larger and more prominent with sequential animation
    const dotData = data.filter((d, i) => i % 3 === 0 || d.value > 30);
    dots = svg.selectAll('.chart-dot')
      .data(dotData)
      .enter()
      .append('circle')
      .attr('class', 'chart-dot')
      .attr('cx', d => xScale(d.date))
      .attr('cy', d => yScale(d.value))
      .attr('r', 0)
      .style('opacity', 0)
      .transition()
      .duration(400)
      .delay((d, i) => 3000 * (i / dotData.length))
      .attr('r', 9)
      .style('opacity', 1);
    
    // Re-select dots for interactivity
    svg.selectAll('.chart-dot')
      .on('mouseover', function(event, d) {
        d3.select(this)
          .transition()
          .duration(150)
          .attr('r', 11);
        
        tooltip
          .style('left', (event.pageX + 15) + 'px')
          .style('top', (event.pageY - 15) + 'px')
          .html(`
            <div class="tooltip-date">${d3.timeFormat('%B %d, %Y')(d.date)}</div>
            <div class="tooltip-value">Search Interest: <strong>${d.value}</strong></div>
          `)
          .classed('visible', true);
      })
      .on('mouseout', function() {
        d3.select(this)
          .transition()
          .duration(150)
          .attr('r', 9);
        
        tooltip.classed('visible', false);
      })
      .on('click', function(event, d) {
        // Add click effect
        const circle = d3.select(this);
        circle
          .transition()
          .duration(300)
          .attr('r', 18)
          .transition()
          .duration(300)
          .attr('r', 9);
      });
    
    // Highlight sustained attention period (2023-2025)
    const sustainedStartDate = new Date('2023-01-01');
    const sustainedData = data.filter(d => d.date >= sustainedStartDate);
    
    // Add shaded region to show consistent attention
    if (sustainedData.length > 0) {
      const sustainedArea = svg.append('path')
        .datum(sustainedData)
        .attr('class', 'sustained-attention-area')
        .attr('d', d3.area()
          .x(d => xScale(d.date))
          .y0(height)
          .y1(d => yScale(d.value))
          .curve(d3.curveMonotoneX)
        )
        .style('fill', 'rgba(29, 155, 240, 0.15)')
        .style('opacity', 0)
        .transition()
        .delay(3200)
        .duration(800)
        .style('opacity', 1);
    }
  }
  
  function updateChart(data) {
    // Update scales
    xScale.domain(d3.extent(data, d => d.date));
    yScale.domain([0, d3.max(data, d => d.value) * 1.15]);
    
    // Clear and re-render
    renderChart(data);
  }
  
  // Add scroll animation for chart appearance
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
      }
    });
  }, {
    threshold: 0.2,
    rootMargin: '0px 0px -100px 0px'
  });
  
  const chartElement = document.querySelector('#searchTrendChart');
  if (chartElement) {
    observer.observe(chartElement);
  }
});

// ========================================
// SENTIMENT VISUALIZATIONS (SCATTER + MAP)
// ========================================
document.addEventListener('DOMContentLoaded', async function() {
  // Country sentiment data (nervous vs excited about AI)
  const sentimentData = {
    'Spain': { nervous: 54.5, excited: 45.5, count: 1141 },
    'South Africa': { nervous: 57.9, excited: 42.1, count: 1107 },
    'Italy': { nervous: 57.1, excited: 42.9, count: 1086 },
    'India': { nervous: 74.5, excited: 25.5, count: 1102 },
    'Brazil': { nervous: 64.9, excited: 35.1, count: 1088 },
    'Mexico': { nervous: 65.2, excited: 34.8, count: 1088 },
    'Canada': { nervous: 51.5, excited: 48.5, count: 1052 },
    'Chile': { nervous: 56.2, excited: 43.8, count: 1096 },
    'China': { nervous: 71.8, excited: 28.2, count: 1077 },
    'Indonesia': { nervous: 68.4, excited: 31.6, count: 1081 },
    'United States': { nervous: 52.6, excited: 47.4, count: 1074 },
    'Poland': { nervous: 55.6, excited: 44.4, count: 1091 },
    'France': { nervous: 50.7, excited: 49.3, count: 1081 },
    'Japan': { nervous: 52.5, excited: 47.5, count: 1048 },
    'Argentina': { nervous: 56.5, excited: 43.5, count: 1341 },
    'Portugal': { nervous: 53.6, excited: 46.4, count: 1071 },
    'Germany': { nervous: 51.6, excited: 48.4, count: 1103 },
    'Kenya': { nervous: 65.6, excited: 34.4, count: 1137 },
    'Pakistan': { nervous: 64.4, excited: 35.6, count: 1173 },
    'Australia': { nervous: 50.3, excited: 49.7, count: 1094 },
    'United Kingdom': { nervous: 50.8, excited: 49.2, count: 1122 }
  };

  // Normalize country names
  const normalizeCountryName = (name) => {
    const nameMap = {
      'United States of America': 'United States',
      'United Kingdom of Great Britain and Northern Ireland': 'United Kingdom',
      'UK': 'United Kingdom',
      'USA': 'United States'
    };
    return nameMap[name] || name;
  };

  // ========================================
  // SCATTER PLOT
  // ========================================
  const scatterContainer = document.getElementById('scatterChart');
  if (scatterContainer) {
    const margin = { top: 40, right: 120, bottom: 60, left: 60 };
    const width = Math.min(1400, window.innerWidth * 0.9) - margin.left - margin.right;
    const height = 550 - margin.top - margin.bottom;

    const svg = d3.select('#scatterChart')
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .style('background', '#000000')
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Scales
    const xScale = d3.scaleLinear()
      .domain([0, 100])
      .range([0, width]);

    const yScale = d3.scaleLinear()
      .domain([0, 100])
      .range([height, 0]);

    // Grid lines
    svg.append('g')
      .selectAll('line.grid-line-x')
      .data(xScale.ticks(10))
      .enter()
      .append('line')
      .attr('class', 'grid-line')
      .attr('x1', d => xScale(d))
      .attr('x2', d => xScale(d))
      .attr('y1', 0)
      .attr('y2', height);

    svg.append('g')
      .selectAll('line.grid-line-y')
      .data(yScale.ticks(10))
      .enter()
      .append('line')
      .attr('class', 'grid-line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', d => yScale(d))
      .attr('y2', d => yScale(d));

    // Reference lines at 50%
    svg.append('line')
      .attr('class', 'reference-line')
      .attr('x1', xScale(50))
      .attr('x2', xScale(50))
      .attr('y1', 0)
      .attr('y2', height);

    svg.append('line')
      .attr('class', 'reference-line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', yScale(50))
      .attr('y2', yScale(50));

    // Tooltip
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'map-tooltip')
      .style('position', 'absolute')
      .style('opacity', 0);

    // Plot points
    const dataArray = Object.entries(sentimentData).map(([country, data]) => ({
      country,
      ...data
    }));

    svg.selectAll('.scatter-dot')
      .data(dataArray)
      .enter()
      .append('circle')
      .attr('class', 'scatter-dot')
      .attr('cx', d => xScale(d.excited))
      .attr('cy', d => yScale(d.nervous))
      .attr('r', 0)
      .attr('fill', '#1D9BF0')
      .attr('opacity', 0.8)
      .transition()
      .duration(800)
      .delay((d, i) => i * 30)
      .attr('r', 6)
      .selection()
      .on('mouseover', function(event, d) {
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', 9);
        
        tooltip
          .html(`
            <div class="country-name">${d.country}</div>
            <div class="sentiment-values">
              <strong>Excited:</strong> ${d.excited.toFixed(1)}%<br/>
              <strong>Nervous:</strong> ${d.nervous.toFixed(1)}%<br/>
              <strong>Respondents:</strong> ${d.count.toLocaleString()}
            </div>
          `)
          .style('left', (event.pageX + 15) + 'px')
          .style('top', (event.pageY - 28) + 'px')
          .style('opacity', 1)
          .classed('visible', true);
      })
      .on('mousemove', function(event) {
        tooltip
          .style('left', (event.pageX + 15) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', function() {
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', 6);
        
        tooltip
          .style('opacity', 0)
          .classed('visible', false);
      });

    // Labels for select countries
    const labeledCountries = ['India', 'China', 'Australia', 'United Kingdom', 'United States', 'Kenya', 'Japan'];
    svg.selectAll('.scatter-label')
      .data(dataArray.filter(d => labeledCountries.includes(d.country)))
      .enter()
      .append('text')
      .attr('class', 'scatter-label')
      .attr('x', d => xScale(d.excited) + 10)
      .attr('y', d => yScale(d.nervous) + 4)
      .text(d => d.country)
      .style('opacity', 0)
      .transition()
      .duration(500)
      .delay(1000)
      .style('opacity', 1);

    // Axes
    const xAxis = d3.axisBottom(xScale)
      .ticks(10)
      .tickFormat(d => d + '%');

    const yAxis = d3.axisLeft(yScale)
      .ticks(10)
      .tickFormat(d => d + '%');

    svg.append('g')
      .attr('class', 'scatter-axis')
      .attr('transform', `translate(0,${height})`)
      .call(xAxis);

    svg.append('g')
      .attr('class', 'scatter-axis')
      .call(yAxis);

    // Axis labels
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', height + 45)
      .style('text-anchor', 'middle')
      .style('fill', '#E7E9EA')
      .style('font-size', '15px')
      .style('font-weight', '600')
      .text('Excited (% of respondents that "Agree")');

    svg.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', -45)
      .style('text-anchor', 'middle')
      .style('fill', '#E7E9EA')
      .style('font-size', '15px')
      .style('font-weight', '600')
      .text('Nervous (% of respondents that "Agree")');
  }

  // ========================================
  // WORLD MAP
  // ========================================
  const mapContainer = document.getElementById('worldMap');
  if (!mapContainer) return;

  const mapWidth = Math.min(1400, window.innerWidth * 0.9);
  const mapHeight = 600;

  const mapSvg = d3.select('#worldMap')
    .append('svg')
    .attr('width', mapWidth)
    .attr('height', mapHeight)
    .attr('viewBox', `0 0 ${mapWidth} ${mapHeight}`)
    .style('background', '#000000');

  const mapTooltip = d3.select('body')
    .append('div')
    .attr('class', 'map-tooltip')
    .style('position', 'absolute')
    .style('opacity', 0);

  const projection = d3.geoNaturalEarth1()
    .scale(mapWidth / 5)
    .translate([mapWidth / 2, mapHeight / 1.8]);

  const path = d3.geoPath().projection(projection);

  // Color scale based on nervous sentiment
  const colorScale = d3.scaleSequential()
    .domain([45, 75])  // Range of nervous values
    .interpolator(d3.interpolateRgb('#4AADFF', '#FF4444'));

  try {
    const world = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    const countries = topojson.feature(world, world.objects.countries);

    mapSvg.selectAll('.country')
      .data(countries.features)
      .enter()
      .append('path')
      .attr('class', d => {
        const countryName = normalizeCountryName(d.properties.name);
        return sentimentData[countryName] ? 'country has-data' : 'country';
      })
      .attr('d', path)
      .attr('fill', d => {
        const countryName = normalizeCountryName(d.properties.name);
        const data = sentimentData[countryName];
        return data ? colorScale(data.nervous) : '#1a1a1a';
      })
      .style('opacity', 0)
      .transition()
      .duration(800)
      .delay((d, i) => i * 2)
      .style('opacity', 1)
      .selection()
      .on('mouseover', function(event, d) {
        const countryName = normalizeCountryName(d.properties.name);
        const data = sentimentData[countryName];

        if (data) {
          mapTooltip
            .html(`
              <div class="country-name">${d.properties.name}</div>
              <div class="sentiment-values">
                <strong>Nervous:</strong> ${data.nervous.toFixed(1)}%<br/>
                <strong>Excited:</strong> ${data.excited.toFixed(1)}%<br/>
                <strong>Respondents:</strong> ${data.count.toLocaleString()}
              </div>
            `)
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 28) + 'px')
            .style('opacity', 1)
            .classed('visible', true);
        }
      })
      .on('mousemove', function(event) {
        mapTooltip
          .style('left', (event.pageX + 15) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', function() {
        mapTooltip
          .style('opacity', 0)
          .classed('visible', false);
      });

  } catch (error) {
    console.error('Error loading map data:', error);
    mapContainer.innerHTML = '<p style="color: #E7E9EA; text-align: center; padding: 2rem;">Map visualization could not be loaded.</p>';
  }
});

